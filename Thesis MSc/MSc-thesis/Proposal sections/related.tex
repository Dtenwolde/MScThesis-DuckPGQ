\section{Related work}
\subsection{Resource Description Framework}
Another form in which graph data can be modelled, aside from the property graph model, is \textit{Resource Description Framework} (RDF). 
Data is modelled in the form of triples, which is composed of a \textit{subject}, \textit{predicate}, and an \textit{object}~\cite{w3rdf}.
The nodes within an RDF can be of three types: Internationalised Resource Identifiers (IRIs) used to globally identify entities and relations, literals, and blank nodes~\cite{10.1145/3447772}.
Node attributes are modelled as an extra outgoing edge (being the predicate) to another node which is the object stored as a literal. 
One way of modelling edge attributes is described by Sun et al.~\cite{DBLP:conf/sigmod/SunFSKHX15}, where every edge attribute requires four new edges being added to the graph.
This method of modelling edge attributes is generally applicable, though verbose and inefficient in terms of storage~\cite{DBLP:conf/sigmod/SunFSKHX15}. 
Database management systems such as BlazeGraph~\cite{blazegraph} and Amazon Neptune~\cite{amazonneptune} have based their data model on RDF. 
Storing RDF data in relational databases has some challenges~\cite{DBLP:conf/sigmod/BorneaDKSDUB13}. 
One way of storing data is by using a single table with three columns: subject, predicate, object. However, large-scale RDF data runs into performance and scalability issues~\cite{DBLP:journals/vldb/NeumannW10}.
In particular, queries containing joins prove to be difficult to handle~\cite{DBLP:journals/vldb/NeumannW10, DBLP:journals/pvldb/Ozsu19}.
\subsection{Self-joins}
Self-joins occur whenever a table joins with itself. For example, a knows table containing two columns (person1\_id, person2\_id) is joined in the following query: 
\begin{lstlisting}[caption=Self-join on the knows table, label=app:selfjoinknows] 
SELECT knows1.person1_id, knows2.person2_id 
FROM knows k1
JOIN knows k2 ON k1.person1_id = k2.person2_id;
\end{lstlisting}

As described by Szarnyas~\cite{self-joins}, there are several challenges with self-joins. An important one is related to RDFs that are stored as one table, which requires a join for every attribute queried~\cite{DBLP:journals/pvldb/Ozsu19}.
Another challenge is related to the hash-joins that are often used by database systems to perform join operations. 
Whenever a join between two tables is performed, the smaller of the two tables is used to build a hash table. 
The other table is then used to probe the hash table and look for matches. 
However, with self-joins, both tables are equal in size, negating the advantage of building a hash table on a smaller table. 
In addition, the resulting table will probably be large in size when the table is of a many-to-many relation. 

\subsection{Mapping from Graph to Relational queries}
Research has been conducted on the translation from a given query language to another one. Work that is particularly interesting to this thesis is translating graph query languages to SQL. 
An example of this is \textit{Cytosm} (Cypher to SQL Mapping) by Steer et al.~\cite{DBLP:conf/grades/SteerALCVV17}. 
It acts as an application to execute graph queries on non-graph databases. 
In addition, they introduced \textit{gTop}, a format that is able to capture the structure of property graphs and allow a mapping between graph query languages and a variety of database management systems. 
Steer et al. find that the translated SQL queries show comparable performance to GDBMSs~\cite{DBLP:conf/grades/SteerALCVV17}.

Another example is GraphGen~\cite{DBLP:conf/grades/Xirogiannopoulos17} that acts as an abstraction layer on top of an RDBMS. 
Underlying relational datasets are transformed and defined as graphs (\textit{Graph-Views}). 
These graphs can then be queried using a graph API. The GraphGen framework has two main functionalities. 
First, users can define the structure of a graph using GraphGenDL, a Datalog-like domain-specific language (DSL). 
The other functionality is taking queries and executing them against the Graph-Views. The queries are specified by GraphGenQL, which is loosely based on SPARQL, Cypher, and PGQL~\cite{DBLP:conf/grades/Xirogiannopoulos17}.

SQLGraph allows Gremlin queries to be converted into SQL~\cite{DBLP:conf/sigmod/SunFSKHX15}. 
It uses a combination of relational and non-relational data storage. The \textit{adjacency information} makes use of relational storage, while the attributes regarding all the nodes and edges are stored with JSON storage.

Lastly, there is IBM Db2 Graph by Tian et al.~\cite{DBLP:conf/sigmod/TianXZPTSKAP20}, which is an in-DBMS graph query approach that supports synergystic and retrofittable graph queries using the query language Gremin inside the IBM Db2 relational database.
Similar to GraphGen, it has a \textit{graph overlay} method that exposes \textit{graph views} of the relational data.  

Zhao and Yu showed that it was possible to support a large class of graph algorithms, such as BFS, Bellman-Ford, PageRank, in SQL~\cite{DBLP:journals/debu/ZhaoY17}.
They introduce new operations, alongside the existing ones (selection, projection, union, set difference, cartesian product, and rename) to provide explicit support for graph algorithms. 